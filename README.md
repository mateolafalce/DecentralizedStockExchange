<div align="center">

  ![stock-exchange](stock-exchange.gif)

  ## Decentralized stock exchange

---

![GitHub Repo stars](https://img.shields.io/github/stars/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)
![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)
![GitHub forks](https://img.shields.io/github/forks/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)

![GitHub](https://img.shields.io/github/license/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)
![GitHub pull requests](https://img.shields.io/github/issues-pr/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)

![GitHub closed pull requests](https://img.shields.io/github/issues-pr-closed-raw/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)
![GitHub closed issues](https://img.shields.io/github/issues-closed/mateolafalce/DecentralizedStockExchange?color=193737&style=for-the-badge)

</div>

---

This exchange is based on the Solana blockchain technology, which makes it completely decentralized and highly secure. Thanks to privacy and decentralization, this stock market allows users to carry out financial transactions completely privately and freely, without the need for intermediaries.

By using web3, the technology that enables interaction with the blockchain, users can enjoy a more secure experience free from manipulation by third parties. This means that users have greater control over their financial assets and can make more informed decisions without worrying about third-party interference. Furthermore, thanks to the decentralized nature of the Solana blockchain, the stock market is resistant to censorship and manipulation, making it a completely fair and transparent free market system.

Next I am going to comment you about the functionalities of the program:

---

<details>

<summary>Initialize the market account üêª</summary>

<br>

```rust
pub fn initialize_decentralized_exchange_system(
    ctx: Context<Initialize>
) -> Result<()> {
    let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
    let (_pda, bump) = Pubkey::find_program_address(&[b"System Account"], ctx.program_id);
    system.bump_original = bump;
    system.total_stock_companies = 0;
    system.historical_exchanges = 0;
    system.total_holders = 0;
    system.total_offers = 0;
    Ok(())
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, seeds = [b"System Account"], bump, payer = user, space = SystemExchangeAccount::SIZE + 8)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}
```

This function takes a Context<Initialize> context and returns a Result<()> .The context contains a user account, a system program account, and an account for the decentralized exchange system to be initialized.The decentralized exchange system account is initialized with the following values:

- bump_original is set to the "bump" value generated by finding the program address using Pubkey::find_program_address.
- total_stock_companies, historical_exchanges, total_holders, and total_offers are all set to zero.

The #[derive(Accounts)] macro defines the requirements for the accounts that are needed for the function, in this case, three accounts are required:

- A SystemExchangeAccount to be initialized.
- A user account that will pay for the initialization of the decentralized exchange system account.
- A system program account that will be used to transact on the blockchain.

</details>

---

<details>

<summary>Create the stock account üìà</summary>

<br>

```rust
pub fn create_stock(
        ctx: Context<CreateStock>,
        name: String,                   
        description: String,            
        total_supply: u64,              
        dividends: bool,                
        dividend_payment_period: i64,   
        date_to_go_public: i64,
        price_to_go_public: u64      
    ) -> Result<()> {
        let (_stock_pda, bump) = Pubkey::find_program_address(&[b"Stock Account", ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(name.len() <= 50, ErrorCode::NameError);
        require!(description.len() <= 200, ErrorCode::DescriptionError);
        require!(date_to_go_public > Clock::get().unwrap().unix_timestamp, ErrorCode::Date);
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        system.total_stock_companies += 1;
        stock_account.bump_original = bump;
        stock_account.pubkey_original = ctx.accounts.from.key();
        stock_account.name = name;
        stock_account.description = description;
        stock_account.total_supply = total_supply;
        stock_account.supply_in_position = total_supply;
        stock_account.holders = 1;
        stock_account.dividends = dividends;
        stock_account.dividend_payment_period = dividend_payment_period;
        stock_account.date_to_go_public = date_to_go_public;
        stock_account.price_to_go_public = price_to_go_public;
        Ok(())
    }

#[derive(Accounts)]
pub struct CreateStock<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(init, seeds = [b"Stock Account", from.key().as_ref()], bump, payer = from, space = StockAccount::SIZE + 8)]
    pub stock_account: Account<'info, StockAccount>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>,
}
```

This function creates a stock stock account. The function takes several parameters, including the name and description of the stock, the total number of shares available, whether and how often dividends will be paid, and the date and price of exit at bag.

The function then creates a new stock stock account using the "StockAccount" data structure and initializes it with the supplied data. It also updates the system account, "SystemExchangeAccount", to record the creation of a new stock company.

The function returns a result indicating whether the operation was successful or not.

</details>

---

<details>

<summary>Create a holder account üì¶</summary>

<br>

```rust
pub fn init_holder_account(
        ctx: Context<InitHolderAccount>
    ) -> Result<()> {
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        let (_holder_pda, bump) = Pubkey::find_program_address(&[ctx.accounts.stock_account.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let holder_account: &mut Account<HolderAccount> = &mut ctx.accounts.holder_account;  
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        holder_account.bump_original = bump;
        holder_account.participation = 0;
        holder_account.holder_pubkey = ctx.accounts.from.key();
        stock_account.holders += 1;
        system.total_holders += 1;
        Ok(())
    }

#[derive(Accounts)]
pub struct InitHolderAccount<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(init, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump, payer = from, space = HolderAccount::SIZE + 8)]
    pub holder_account: Account<'info, HolderAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The init_holder_account function is a public (pub) function that is used to initialize a holder account on the decentralized exchange program. This function takes a context (ctx) that includes a data structure called InitHolderAccount that is used to get information about the accounts relevant to the function.

The function checks if the PDA account public key of the stock account matches the provided stock account public key, and if not, returns an ErrorCode. If the public keys match, a unique Program Derived Address (PDA) key is generated for the holder account using the public keys of the stock account and the "from" account.

The function then updates various accounts, including the decentralized exchange system account, the holder account, and the stock account. The number of holders and the participation account are increased in the holder account, and the total number of holders is increased in the decentralized exchange system account.

</details>

---

<details>

<summary>Create a buyer account üõí</summary>

<br>

```rust
pub fn init_buy_account(
        ctx: Context<InitBuyAccount>
    ) -> Result<()> {
        let (_buy_pda, bump) = Pubkey::find_program_address(&[b"Buy Account", ctx.accounts.stock_account_pda.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        let buy_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.buy_offer;
        buy_offer.bump_original = bump;
        buy_offer.sell_or_buy_amount = [].to_vec();
        buy_offer.price = [].to_vec();
        buy_offer.pubkey = ctx.accounts.from.key();
        buy_offer.len = 65;
        Ok(())
    }

#[derive(Accounts)]
pub struct InitBuyAccount<'info> {
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(init, seeds = [b"Buy Account", stock_account.key().as_ref(), from.key().as_ref()], bump, payer = from, space = SellOrBuyAccount::SIZE + 8)]
    pub buy_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The function takes a context (Context) as input and returns a result (Result). The context includes information about the accounts that will be used in the transaction, such as the stock account to be purchased, the offer to buy account, and the program account itself.

Within the function, the find_program_address function is used to find the address of the program account (_buy_pda) to use for the buy offer. A security check is also performed to ensure that the share account to be purchased is the same as the share account specified in the offer to buy account.

The buy_offer account is then initialized using the Accounts macro. It is specified that the account must be mutable (mut) and the seeds (seeds) necessary to initialize the account are provided. The account is initialized with a specific space (space) and it is specified that the account will be paid from the sender's account (payer).

Finally, the necessary information is established in the offer to buy account, including the size of the account (len), the public address (pubkey) of the sender and the number of shares to buy and their price (sell_or_buy_amount and price, respectively). ). The function returns an Ok(()) result to indicate that the operation was successful.

</details>

---

<details>

<summary>Create a seller account üí∞</summary>

<br>

```rust
pub fn init_sell_account(
        ctx: Context<InitSellAccount>
    ) -> Result<()> {
        let (_sell_pda, bump) = Pubkey::find_program_address(&[b"Sell Account", ctx.accounts.stock_account.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        let sell_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.sell_offer;
        sell_offer.bump_original = bump;
        sell_offer.sell_or_buy_amount = [].to_vec();
        sell_offer.price = [].to_vec();
        sell_offer.pubkey = ctx.accounts.from.key();
        sell_offer.len = 65;
        Ok(())
    }

#[derive(Accounts)]
pub struct InitSellAccount<'info> {
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(init, seeds = [b"Sell Account", stock_account_pda.key().as_ref(), from.key().as_ref()], bump, payer = from, space = SellOrBuyAccount::SIZE + 8)]
    pub sell_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The init_sell_account function is responsible for initializing a sale account on the blockchain. It takes as input a Context object that contains information about the program and the current transaction. In particular, the Context object is expected to contain information about the stock account (stock_account) that is going to be sold, as well as information about the user account (from) that is making the sale.

The function uses the share and user account information to calculate a unique public account address (_sell_pda) for the sell account being initialized. This address is used to ensure that only the user account corresponding to the sale can perform operations on the sale account.

The function then does some validation to make sure that the share accounts and the user account are valid. If these validations are successful, the function initializes the sales account with the information provided. In particular, the function sets the sale price and the number of shares available for sale, as well as the public address of the user account that is making the sale.

</details>

---

<details>

<summary>Create an IPO üéâ</summary>

<br>

```rust
pub fn buy_in_initial_public_offering(
        ctx: Context<BuyInitialPublicOffering>,
        amount: u64
    ) -> Result<()> {
        let (holder_pda, _bump) = Pubkey::find_program_address(&[ctx.accounts.stock_account.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(amount > 0, ErrorCode::AmountError);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(amount <= ctx.accounts.stock_account.total_supply, ErrorCode::SupplyError);
        require!(holder_pda.key() == ctx.accounts.holder_account.key(), ErrorCode::HolderError);
        let amount_to_send: u64 = ctx.accounts.stock_account.price_to_go_public * amount;
        anchor_lang::solana_program::program::invoke(
        &system_instruction::transfer(&ctx.accounts.from.key(), &ctx.accounts.stock_account_pda.key(), amount_to_send),
        &[ctx.accounts.from.to_account_info(), ctx.accounts.stock_account_pda.to_account_info().clone()],
        ).expect("Error");
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let holder_account: &mut Account<HolderAccount> = &mut ctx.accounts.holder_account;  
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        holder_account.participation = amount;
        stock_account.supply_in_position -= amount;
        system.historical_exchanges += 1;
        Ok(())
    }

#[derive(Accounts)]
pub struct BuyInitialPublicOffering<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = holder_account.bump_original)]
    pub holder_account: Account<'info, HolderAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The function takes as input a context and an amount, and returns a result. The context entry includes accounts associated with the decentralized exchange system, the share token account, the holder account, and other accounts required to perform the transaction. The feature uses a series of security checks to verify that the amount is greater than zero, that the accounts are authentic, and that the holder has enough tokens to make the purchase.

If these conditions are met, the function performs the transfer of tokens from the buyer's account to the holder's account and updates the information of the holder's account, the stock token account, and the decentralized exchange system account.

</details>

---

<details>

<summary>Make a sell offer ‚ú®</summary>

<br>

```rust
pub fn sell_offer(
        ctx: Context<SellOffer>,
        sell_amount: u64,
        price: u64
    ) -> Result<()> {
        require!(sell_amount <= ctx.accounts.holder_account.participation, ErrorCode::AmountError);
        let sell_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.sell_offer;
        fn unique_elements<T>(iter: T) -> bool
        where
            T: IntoIterator,
            T::Item: Ord,
        {
            let mut uniq = BTreeSet::new();
            iter.into_iter().all(move |x| uniq.insert(x))
        }
        let mut copy = sell_offer.price.clone();
        require!(unique_elements(vec![copy.push(price)]) == true, ErrorCode::UniquePriceError);
        let (holder_pda, _bump) = Pubkey::find_program_address(&[ctx.accounts.stock_account.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(sell_amount > 0, ErrorCode::AmountError);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(holder_pda.key() == ctx.accounts.holder_account.key(), ErrorCode::HolderError);
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        let holder_account: &mut Account<HolderAccount> = &mut ctx.accounts.holder_account;
        sell_offer.sell_or_buy_amount.push(sell_amount);
        sell_offer.price.push(price);
        sell_offer.len += 16;
        system.total_offers += 1;
        stock_account.current_offers += 1;
        holder_account.participation -= sell_amount;
        Ok(())
    }

#[derive(Accounts)]
pub struct SellOffer<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = holder_account.bump_original)]
    pub holder_account: Account<'info, HolderAccount>,
    #[account(
        mut,
        seeds = [b"Sell Account", stock_account_pda.key().as_ref(), from.key().as_ref()],
        bump = sell_offer.bump_original,
        realloc = 8 + sell_offer.len as usize + 16,
        realloc::payer = from,
        realloc::zero = false,
    )]
    pub sell_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

This function represents a sell offer on a decentralized exchange system. It takes in three parameters: a context, a sell amount, and a price. The function first checks if the sell amount is less than or equal to the participating amount of the holder account, and if it is not, it returns an error.

The function then checks for the uniqueness of the price in the sell offer by calling a nested function unique_elements. If the price is not unique, the function returns an error. Next, the function generates a program-derived address (PDA) for the holder account and checks if it matches the holder account provided. It also checks if the sell amount is greater than zero and if the stock account PDA key matches the provided stock account key.

The function then updates the relevant accounts by incrementing their relevant counters and appending the sell amount and price to the sell offer account. Finally, the function returns an Ok(()) result.

</details>

---

<details>

<summary>Make a buy offer üíé</summary>

<br>

```rust
pub fn buy_offer(
        ctx: Context<BuyOffer>,
        buy_amount: u64,
        price: u64
    ) -> Result<()> {
        let (holder_pda, _bump) = Pubkey::find_program_address(&[ctx.accounts.stock_account.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(holder_pda.key() == ctx.accounts.holder_account.key(), ErrorCode::HolderError);
        require!(buy_amount > 0, ErrorCode::AmountError);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(buy_amount <= ctx.accounts.stock_account.total_supply, ErrorCode::AmountError);
        require!(ctx.accounts.buy_offer.key() == ctx.accounts.buy_pda.key(), ErrorCode::PubkeyError);
        anchor_lang::solana_program::program::invoke(
            &system_instruction::transfer(&ctx.accounts.from.key(), &ctx.accounts.buy_offer.key(), price),
            &[ctx.accounts.from.to_account_info(), ctx.accounts.buy_pda.to_account_info().clone()],
        ).expect("Error");
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        let holder_account: &mut Account<HolderAccount> = &mut ctx.accounts.holder_account;
        let buy_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.buy_offer;
        buy_offer.sell_or_buy_amount.push(buy_amount);
        buy_offer.price.push(price);
        buy_offer.len += 16;
        system.total_offers += 1;
        stock_account.current_offers += 1;
        Ok(())
    }

#[derive(Accounts)]
pub struct BuyOffer<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(
        mut,
        seeds = [b"Buy Account", stock_account_pda.key().as_ref(), from.key().as_ref()],
        bump = buy_offer.bump_original,
        realloc = 8 + buy_offer.len as usize + 16,
        realloc::payer = from,
        realloc::zero = false,
    )]
    pub buy_offer: Account<'info, SellOrBuyAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = holder_account.bump_original)]
    pub holder_account: Account<'info, HolderAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub buy_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The function takes as input a ctx context structure, the amount of assets to buy buy_amount and the bid price price. First, the function verifies the authenticity of the offer holder's account and the validity of the quantity and parameters of the asset account and the offer to buy. It then invokes the transfer function of the Solana system program to transfer the necessary funds from the buyer's account to the purchase offer account.

The accounts for the decentralized systems and the assets involved in the offer are then updated, and the offer details are added to the offer to buy account. Finally, a result is returned indicating the success or failure of the transaction. The BuyOffer framework defines the account requirements and the account information needed to complete the transaction.

</details>

---

<details>

<summary>Accept a sell offer üëç</summary>

<br>

```rust
pub fn accept_a_sell(
        ctx: Context<AcceptASell>,
        price: u64
    ) -> Result<()> {
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(ctx.accounts.sell_offer.key() == ctx.accounts.sell_pda.key(), ErrorCode::PubkeyError);
        let index = ctx.accounts.sell_offer.price.iter().position(|&price| price == price).unwrap();
        require!(price == ctx.accounts.sell_offer.price[index], ErrorCode::PriceError);
        anchor_lang::solana_program::program::invoke(
            &system_instruction::transfer(&ctx.accounts.from.key(), &ctx.accounts.sell_offer.key(), ctx.accounts.sell_offer.price[index]),
            &[ctx.accounts.from.to_account_info(), ctx.accounts.sell_pda.to_account_info().clone()],
        ).expect("Error");
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        let seller_account: &mut Account<HolderAccount> = &mut ctx.accounts.seller_account;
        let buyer_account: &mut Account<HolderAccount> = &mut ctx.accounts.buyer_account;
        let sell_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.sell_offer;
        system.historical_exchanges += 1;
        system.total_offers -= 1;
        stock_account.current_offers -= 1;
        seller_account.participation -= sell_offer.sell_or_buy_amount[index];
        buyer_account.participation += sell_offer.sell_or_buy_amount[index];
        sell_offer.sell_or_buy_amount.remove(index);
        sell_offer.price.remove(index);
        sell_offer.len -= 16;
        Ok(())
    }

#[derive(Accounts)]
pub struct AcceptASell<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = seller_account.bump_original)]
    pub seller_account: Account<'info, HolderAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = buyer_account.bump_original)]
    pub buyer_account: Account<'info, HolderAccount>,
    #[account(
        mut,
        seeds = [b"Sell Account", stock_account_pda.key().as_ref(), from.key().as_ref()],
        bump = sell_offer.bump_original,
        realloc = 8 + sell_offer.len as usize - 16,
        realloc::payer = from,
        realloc::zero = false,
    )]
    pub sell_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub sell_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```
Its purpose is to accept a sell offer from a holder account and execute the transaction by transferring the tokens to the buyer and updating the relevant accounts.The function takes in the following parameters:

- ctx: An anchor context that provides access to the accounts used in the function.
- price: The price at which the sell offer is made.

The function first verifies that the sell offer is valid by checking that the necessary accounts and their keys are present. It then finds the index of the sell offer price in the price vector using the iter() and position() functions. The function then checks that the price provided matches the sell offer price at the obtained index.

If the sell offer is valid, the function invokes the system_instruction::transfer() function to transfer the tokens from the seller's account to the buyer's account using the invoke() function. It then updates the accounts' information by incrementing or decrementing the relevant fields. The accounts used in the function are defined using the Accounts struct. They are:

- decentralized_exchange_system: The system account that holds information about the exchange system.
- stock_account: The account that holds information about the stock tokens.
- seller_account: The holder account that is making the sell offer.
- buyer_account: The holder account that is buying the stock.
- sell_offer: The sell offer account that contains information about the sell offer.
- stock_account_pda: The program-derived account (PDA) associated with the stock account.
- sell_pda: The PDA associated with the sell offer account.
- from: The signer account that is initiating the transaction.
- system_program: The system program account used to invoke the system_instruction::transfer() function.
This function is defined as a Rust public function with the signature pub fn accept_a_sell(ctx: Context<AcceptASell>, price: u64) -> Result<()>. It returns a Result<()> indicating the success or failure of the transaction.

</details>

---

<details>

<summary>Accept a buy offer üõí</summary>

<br>

```rust
pub fn accept_a_buy(
        ctx: Context<AcceptABuy>,
        price: u64
    ) -> Result<()> {
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(ctx.accounts.buy_offer.key() == ctx.accounts.buyer_pda.key(), ErrorCode::PubkeyError);
        let index = ctx.accounts.buy_offer.price.iter().position(|&price| price == price).unwrap();
        require!(price == ctx.accounts.buy_offer.price[index], ErrorCode::PriceError);
        **ctx.accounts.buy_offer.to_account_info().try_borrow_mut_lamports()? -= price;
        **ctx.accounts.from.to_account_info().try_borrow_mut_lamports()? += price;
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        let seller_account: &mut Account<HolderAccount> = &mut ctx.accounts.seller_account;
        let buyer_account: &mut Account<HolderAccount> = &mut ctx.accounts.buyer_account;
        let buy_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.buy_offer;
        system.historical_exchanges += 1;
        system.total_offers -= 1;
        stock_account.current_offers -= 1;
        seller_account.participation -= buy_offer.sell_or_buy_amount[index];
        buyer_account.participation += buy_offer.sell_or_buy_amount[index];//I
        buy_offer.sell_or_buy_amount.remove(index);
        buy_offer.price.remove(index);
        buy_offer.len -= 16;
        Ok(())
    }

#[derive(Accounts)]
pub struct AcceptABuy<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = seller_account.bump_original)]
    pub seller_account: Account<'info, HolderAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = buyer_account.bump_original)]
    pub buyer_account: Account<'info, HolderAccount>,
    #[account(
        mut,
        seeds = [b"Buy Account", stock_account_pda.key().as_ref(), from.key().as_ref()],
        bump = buy_offer.bump_original,
        realloc = 8 + buy_offer.len as usize - 16,
        realloc::payer = from,
        realloc::zero = false,
    )]
    pub buy_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub buyer_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The function accepts two arguments: "ctx" and "price". "ctx" is a context containing all accounts relevant to the transaction, while "price" is the price of the bid.

The function first performs some checks to make sure that the transaction is valid and secure. Then, update the details of the accounts involved in the transaction. In particular, it reduces the account balance of the purchase offer in "price" units and increases the account balance of the seller in "price" units. Then, update the counters and tracking data for the decentralized exchange.

</details>

---

<h3 align="center">Cancel a sell offer</h3>

```rust
pub fn cancel_sell(
        ctx: Context<CancelSellOffer>,
        price_to_cancel: u64
    ) -> Result<()> {
        let (holder_pda, _bump) = Pubkey::find_program_address(&[ctx.accounts.stock_account.key().as_ref(), ctx.accounts.from.key().as_ref()], ctx.program_id);
        require!(price_to_cancel > 0, ErrorCode::AmountError);
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(holder_pda.key() == ctx.accounts.holder_account.key(), ErrorCode::HolderError);
        //require!(price_to_cancel <= ctx.accounts.holder_account.commercial_participation, ErrorCode::AmountError);
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        let holder_account: &mut Account<HolderAccount> = &mut ctx.accounts.holder_account;
        let sell_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.sell_offer;
        let index = sell_offer.price.iter().position(|&price| price == price_to_cancel).unwrap();
        require!(price_to_cancel == sell_offer.price[index], ErrorCode::PriceError);
        let index = sell_offer.price.iter().position(|&price| price == price_to_cancel).unwrap();
        sell_offer.sell_or_buy_amount.remove(index);
        sell_offer.price.remove(index);
        sell_offer.len -= 16;
        system.total_offers -= 1;
        stock_account.current_offers -= 1;
        holder_account.participation += price_to_cancel;
        Ok(())
    }

#[derive(Accounts)]
pub struct CancelSellOffer<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(mut, seeds = [stock_account_pda.key().as_ref(), from.key().as_ref()], bump = holder_account.bump_original)]
    pub holder_account: Account<'info, HolderAccount>,
    #[account(
        mut,
        seeds = [b"Sell Account", stock_account.key().as_ref(), from.key().as_ref()],
        bump = sell_offer.bump_original,
        realloc = 8 + sell_offer.len as usize - 16,
        realloc::payer = from,
        realloc::zero = false,
    )]
    pub sell_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

The function is responsible for canceling an existing sale offer in the exchange system, returning the sold tokens to the owner of the sale account. The function takes as input a CancelSellOffer structure, which contains the accounts needed to cancel the sale offer. It is required that the sale offer is valid and that the cancellation price is greater than zero.

The function first looks up the public address of the put holder's account and checks if it matches the public address stored in the exchange system. It also verifies that the public address of the account holder of the offer to sell is the same as the public address of the holder of the selling account being cancelled.

The function then looks up the sales quote in the sales account and removes the sales quote corresponding to the cancellation price. The corresponding accounts are then updated to reflect the cancellation of the offer, including the reduction of the total number of offers in the system and the number of sales offers in the stock account. Finally, control is returned to the user and a result is returned indicating whether the cancellation was successful.

<h3 align="center">Cancel a buy offer</h3>

```rust
pub fn cancel_buy(
        ctx: Context<CancelBuyOffer>,
        price_to_cancel: u64
    ) -> Result<()> {
        require!(ctx.accounts.stock_account_pda.key() == ctx.accounts.stock_account.key(), ErrorCode::PubkeyError);
        require!(ctx.accounts.buy_offer.key() == ctx.accounts.buy_pda.key(), ErrorCode::PubkeyError);
        let system: &mut Account<SystemExchangeAccount> = &mut ctx.accounts.decentralized_exchange_system;
        let stock_account: &mut Account<StockAccount> = &mut ctx.accounts.stock_account;
        let buy_offer: &mut Account<SellOrBuyAccount> = &mut ctx.accounts.buy_offer;
        let index = buy_offer.price.iter().position(|&price| price == price_to_cancel).unwrap();
        require!(price_to_cancel == buy_offer.price[index], ErrorCode::PriceError);
        buy_offer.sell_or_buy_amount.remove(index);
        buy_offer.price.remove(index);
        buy_offer.len -= 16;
        system.total_offers -= 1;
        stock_account.current_offers -= 1;
        **ctx.accounts.buy_pda.to_account_info().try_borrow_mut_lamports()? -= price_to_cancel;
        **ctx.accounts.from.to_account_info().try_borrow_mut_lamports()? += price_to_cancel;
        Ok(())
    }

#[derive(Accounts)]
pub struct CancelBuyOffer<'info> {
    #[account(mut, seeds = [b"System Account"], bump = decentralized_exchange_system.bump_original)]
    pub decentralized_exchange_system: Account<'info, SystemExchangeAccount>,
    #[account(mut, seeds = [b"Stock Account", stock_account.pubkey_original.key().as_ref()], bump = stock_account.bump_original)]
    pub stock_account: Account<'info, StockAccount>,
    #[account(
        mut,
        seeds = [b"Buy Account", stock_account.key().as_ref(), from.key().as_ref()],
        bump = buy_offer.bump_original,
        realloc = 8 + buy_offer.len as usize - 16,
        realloc::payer = from,
        realloc::zero = false,
    )]
    pub buy_offer: Account<'info, SellOrBuyAccount>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub stock_account_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut)]
    pub buy_pda: AccountInfo<'info>,
    /// CHECK: This is not dangerous
    #[account(mut, signer)]
    pub from: AccountInfo<'info>,
    pub system_program: Program<'info, System>
}
```

To use this function, you must pass in the following parameters:
- ctx: A Context object that contains information about the current transaction.
- price_to_cancel: The price of the buy offer that you want to cancel.
The cancel_buy function first checks that the stock account PDA key matches the stock account key and that the buy offer key matches the buy PDA key. If these checks fail, it will return an error code. Next, the function initializes some mutable variables for the system exchange account, stock account, and buy offer. It then uses the iter.position() method to find the index of the buy offer with the specified price. If the price is not found, it will return an error code.

If the price is found, the function removes the sell or buy amount and price from the buy offer account, decrements the total number of offers in the system, and decrements the number of current offers for the stock account. It then returns any funds that were locked up for the canceled buy offer by transferring the lamports from the buy PDA account to the from account. Finally, the function returns an Ok(()) result if everything was successful.
This function requires access to several accounts, which are specified in the CancelBuyOffer struct:

- decentralized_exchange_system: The system exchange account for the decentralized exchange.
- stock_account: The stock account associated with the buy offer.
- buy_offer: The buy offer account that is being canceled.
- stock_account_pda: The PDA for the stock account. This account is not dangerous.
- buy_pda: The PDA for the buy offer. This account is not dangerous.
- from: The account that will receive the returned lamports.
- system_program: The system program account for Solana.
